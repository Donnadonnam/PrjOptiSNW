
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>SNW_VFI_MAIN Solves Policy/Value Function SNW (Bisection Vectorized)</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-07-04"><meta name="DC.source" content="snw_vfi_main_bisec_vec.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>SNW_VFI_MAIN Solves Policy/Value Function SNW (Bisection Vectorized)</h1><!--introduction--><pre>  Given parameters, iterate over life cycle, given age, marital status,
  education level and child count, as well as persistent productivity
  shock process, solve for optimal dynamic savings choices given
  expectation of kid count transition and productivity shock transition.</pre><pre>  Pref, Technology, and prices SCALARS:</pre><pre>  * BETA discount
  * THETA total factor productivity normalizer
  * R interest rate</pre><pre>  Vectorized State Space ARRAYS:</pre><pre>  * AGRID asset grid
  * ETA_GRID productivity shock grid</pre><pre>  Transition Matrixes ARRAYS:</pre><pre>  * PI_ETA shock productivity transition
  * PI_KIDS shock kids count transition
  * PSI shock survival probability</pre><pre>  Permanent Education Type Heterogeneity ARRAYS:</pre><pre>  * EPSILON perfect-foresight education type transition
  * SS Social Security</pre><pre>  [V_VFI,AP_VFI,CONS_VFI,EXITFLAG_VFI] = SNW_VFI_MAIN(MP_PARAMS) invoke
  model with externally set parameter map MP_PARAMS.</pre><pre>  [V_VFI,AP_VFI,CONS_VFI,EXITFLAG_VFI] = SNW_VFI_MAIN(MP_PARAMS,
  MP_CONTROLS) invoke model with externally set parameter map MP_PARAMS
  as well as control mpa MP_CONTROLS.</pre><pre>  [V_VFI,AP_VFI,CONS_VFI,EXITFLAG_VFI] = SNW_VFI_MAIN(MP_PARAMS,
  MP_CONTROLS, V_VFI_FIX) provides existing value function. Suppose
  there is sudden shock, but future value is preserved after one period.
  So now we have new value that is specific to this period, that is the
  output V_VFI, the input V_VFI_FIX is the value for all future periods.
  When this program is called with V_VFI_FIX, the resource equation will
  use the unemployment shock information.</pre><pre>  See also SNWX_VFI_MAIN, SNW_MP_CONTROL, SNW_MP_PARAM</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Default and Parse</a></li><li><a href="#4">Reset All globals</a></li><li><a href="#5">Parse Model Parameters</a></li><li><a href="#6">Parse Model Controls</a></li><li><a href="#7">Define Functions</a></li><li><a href="#8">Timing and Profiling Start</a></li><li><a href="#9">Solve optimization problem</a></li><li><a href="#10">Timing and Profiling End</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [V_VFI,ap_VFI,cons_VFI,exitflag_VFI]=snw_vfi_main_bisec_vec(varargin)
</pre><h2 id="3">Default and Parse</h2><pre class="codeinput"><span class="keyword">if</span> (~isempty(varargin))

    <span class="keyword">if</span> (length(varargin)==1)
        [mp_params] = varargin{:};
        mp_controls = snw_mp_control(<span class="string">'default_base'</span>);
    <span class="keyword">elseif</span> (length(varargin)==2)
        [mp_params, mp_controls] = varargin{:};
    <span class="keyword">elseif</span> (length(varargin)==3)
        [mp_params, mp_controls, V_VFI_POSTSHOCK] = varargin{:};
    <span class="keyword">end</span>

<span class="keyword">else</span>

    mp_params = snw_mp_param(<span class="string">'default_small'</span>);
    mp_controls = snw_mp_control(<span class="string">'default_test'</span>);

<span class="keyword">end</span>
</pre><h2 id="4">Reset All globals</h2><p>globals = who('global'); clear(globals{:}); Parameters used in this code directly</p><pre class="codeinput"><span class="keyword">global</span> beta theta r agrid epsilon SS pi_eta pi_kids psi n_jgrid n_agrid n_etagrid n_educgrid n_marriedgrid n_kidsgrid
<span class="comment">% Used in functions that are called by this code</span>
<span class="keyword">global</span> gamma g_n g_cons a2 cons_allocation_rule jret
<span class="comment">% July 1st new parameters</span>
<span class="keyword">global</span> eta_H_grid eta_S_grid Bequests bequests_option throw_in_ocean
</pre><h2 id="5">Parse Model Parameters</h2><pre class="codeinput">params_group = values(mp_params, {<span class="keyword">...</span>
    <span class="string">'gamma'</span>, <span class="string">'beta'</span>, <span class="string">'theta'</span>, <span class="string">'cons_allocation_rule'</span>, <span class="keyword">...</span>
    <span class="string">'r'</span>, <span class="string">'g_n'</span>, <span class="string">'g_cons'</span>, <span class="string">'a2'</span>, <span class="string">'jret'</span>});
[gamma, beta, theta, cons_allocation_rule, <span class="keyword">...</span>
    r, g_n, g_cons, a2, jret] = params_group{:};

params_group = values(mp_params, {<span class="string">'Bequests'</span>, <span class="string">'bequests_option'</span>, <span class="string">'throw_in_ocean'</span>});
[Bequests, bequests_option, throw_in_ocean] = params_group{:};

params_group = values(mp_params, {<span class="string">'agrid'</span>, <span class="string">'eta_H_grid'</span>, <span class="string">'eta_S_grid'</span>});
[agrid, eta_H_grid, eta_S_grid] = params_group{:};

params_group = values(mp_params, <span class="keyword">...</span>
    {<span class="string">'pi_eta'</span>, <span class="string">'pi_kids'</span>, <span class="string">'psi'</span>});
[pi_eta, pi_kids, psi] = params_group{:};

params_group = values(mp_params, {<span class="string">'epsilon'</span>, <span class="string">'SS'</span>});
[epsilon, SS] = params_group{:};

params_group = values(mp_params, <span class="keyword">...</span>
    {<span class="string">'n_jgrid'</span>, <span class="string">'n_agrid'</span>, <span class="string">'n_etagrid'</span>, <span class="string">'n_educgrid'</span>, <span class="string">'n_marriedgrid'</span>, <span class="string">'n_kidsgrid'</span>});
[n_jgrid, n_agrid, n_etagrid, n_educgrid, n_marriedgrid, n_kidsgrid] = params_group{:};

<span class="comment">% unemployment parameters under covid</span>
<span class="keyword">if</span> (length(varargin)==3)
    params_group = values(mp_params, {<span class="string">'xi'</span>,<span class="string">'b'</span>});
    [xi, b] = params_group{:};
<span class="keyword">end</span>
</pre><h2 id="6">Parse Model Controls</h2><p>Profiling Controls</p><pre class="codeinput">params_group = values(mp_controls, {<span class="string">'bl_timer'</span>});
[bl_timer] = params_group{:};

<span class="comment">% Display Controls</span>
params_group = values(mp_controls, {<span class="string">'bl_print_vfi'</span>, <span class="string">'bl_print_vfi_verbose'</span>});
[bl_print_vfi, bl_print_vfi_verbose] = params_group{:};

<span class="comment">% Store Controls</span>
params_group = values(mp_controls, {<span class="string">'bl_vfi_store_all'</span>});
[bl_vfi_store_all] = params_group{:};
</pre><h2 id="7">Define Functions</h2><pre class="codeinput"><span class="comment">% Current Function and their Derivatives</span>
hh_power=1/cons_allocation_rule;
<span class="keyword">if</span>(gamma == 1)
    f_util = @(c,hh_size) log(c./(hh_size.^hh_power));
    f_du_da = @(c,hh_size) (-1)./(c);
<span class="keyword">else</span>
    f_util = @(c,hh_size) ((c./(hh_size.^hh_power)).^(1-gamma)-1)./(1-gamma);
    f_du_da = @(c,hh_size) (-(hh_size.^(hh_power.*(gamma-1))))./(c.^gamma);
<span class="keyword">end</span>

<span class="comment">% Utility</span>
f_U = @(u, Ev) (u + beta.*Ev);
f_FOC = @(duda, devda) (duda + beta.*devda);
</pre><h2 id="8">Timing and Profiling Start</h2><pre class="codeinput"><span class="keyword">if</span> (bl_timer)
    tic
<span class="keyword">end</span>
</pre><h2 id="9">Solve optimization problem</h2><pre class="codeinput">V_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
ap_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
cons_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
<span class="comment">% if (bl_vfi_store_all)</span>
<span class="comment">%     y_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);</span>
<span class="comment">%     tax_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);</span>
<span class="comment">%     SS_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);</span>
<span class="comment">% end</span>

exitflag_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);

<span class="comment">% Solve for value function and policy functions by means of backwards induction</span>
<span class="keyword">for</span> j=n_jgrid:(-1):1 <span class="comment">% Age</span>

    <span class="comment">% A1. Generate the Resources Matrix</span>
    mn_resources = zeros(n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
    mn_z_ctr = zeros(n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
    mn_hh_size = zeros(n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
    <span class="keyword">for</span> a=1:n_agrid <span class="comment">% Assets</span>
        it_z_ctr = 0;
        <span class="comment">% order here is reverse of order of loops at L181, so that it_z_ctr</span>
        <span class="comment">% match up with column order after reshape(mn_ev_ap_z, n_agrid, [])</span>
        <span class="keyword">for</span> kids=1:n_kidsgrid <span class="comment">% Number of kids</span>
            <span class="keyword">for</span> married=1:n_marriedgrid <span class="comment">% Marital status</span>
                <span class="keyword">for</span> educ=1:n_educgrid <span class="comment">% Educational level</span>
                    <span class="keyword">for</span> eta=1:n_etagrid <span class="comment">% Productivity</span>

                        <span class="comment">% Resources</span>
                        <span class="keyword">if</span> (length(varargin)==3)
                            <span class="comment">% one period unemployed shock</span>
                            [inc,earn]=individual_income(j,a,eta,educ,xi,b);
                        <span class="keyword">else</span>
                            [inc,earn]=individual_income(j,a,eta,educ);
                        <span class="keyword">end</span>
                        spouse_inc=spousal_income(j,educ,kids,earn,SS(j,educ));
                        resources = (1+r)*(agrid(a)+Bequests*(bequests_option-1)) <span class="keyword">...</span>
                                    + epsilon(j,educ)*theta*exp(eta_H_grid(eta)) <span class="keyword">...</span>
                                    + SS(j,educ) <span class="keyword">...</span>
                                    + (married-1)*spouse_inc*exp(eta_S_grid(eta)) <span class="keyword">...</span>
                                    - max(0,Tax(inc,(married-1)*spouse_inc*exp(eta_S_grid(eta))));
                        mn_resources(a, eta, educ, married, kids) = resources;

                        <span class="comment">% Non-asset position Counter</span>
                        it_z_ctr = it_z_ctr + 1;
                        mn_z_ctr(a, eta, educ, married, kids) = it_z_ctr;

                        <span class="comment">% Household Size: 1 kid married, hh_size = 2 + 2 -</span>
                        <span class="comment">% 1 = 3. 0 kid and unmarried hh_size = 1 + 1 - 1 =</span>
                        <span class="comment">% 1</span>
                        hh_size = married + kids - 1; <span class="comment">% m=1 if single; m=2 if married; k=1 if 0 children</span>
                        mn_hh_size(a, eta, educ, married, kids) = hh_size;

                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% array states/shocks all</span>
    ar_resources_amz = mn_resources(:);
    ar_z_ctr_amz = mn_z_ctr(:);
    ar_hh_size_amz = mn_hh_size(:);

    <span class="comment">% A2. Solve For EV(ap,z) = EV(ap,zp|z)f(zp|z) for all possible ap points</span>
    <span class="comment">% ev = 0 in final decision period.</span>
    mn_ev_ap_z = zeros(n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);

    <span class="keyword">if</span> (j~=n_jgrid)

        <span class="keyword">if</span> (length(varargin)==3)
            V_VFI_FUTURE = V_VFI_POSTSHOCK;
        <span class="keyword">else</span>
            V_VFI_FUTURE = V_VFI;
        <span class="keyword">end</span>

        <span class="keyword">for</span> eta=1:n_etagrid <span class="comment">% Productivity</span>
            <span class="keyword">for</span> educ=1:n_educgrid <span class="comment">% Educational level</span>
                <span class="keyword">for</span> married=1:n_marriedgrid <span class="comment">% Marital status</span>
                    <span class="keyword">for</span> kids=1:n_kidsgrid <span class="comment">% Number of kids</span>
                        <span class="keyword">for</span> a=1:n_agrid
                            <span class="comment">% Add to each cell of mt_ev_ap_z, integrating over f(zp|z)</span>
                            <span class="keyword">for</span> etap=1:n_etagrid
                                <span class="keyword">for</span> kidsp=1:n_kidsgrid
                                    mn_ev_ap_z(a,eta,educ,married,kids) = <span class="keyword">...</span>
                                        mn_ev_ap_z(a,eta,educ,married,kids) <span class="keyword">...</span>
                                        + psi(j)*pi_eta(eta,etap)*pi_kids(kids,kidsp,j,educ,married)<span class="keyword">...</span>
                                          *V_VFI_FUTURE(j+1,a,etap,educ,married,kidsp);
                                <span class="keyword">end</span>
                            <span class="keyword">end</span>

                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% B1. z specific EV Slope: EV(ap,z)/d(ap)</span>
        mn_deri_dev_dap = diff(mn_ev_ap_z, 1)./diff(agrid);
        <span class="comment">% B2. ND dimensional Array to 2D dimensional Array:</span>
        mt_ev_ap_z = reshape(mn_ev_ap_z, n_agrid, []);
        mt_deri_dev_dap = reshape(mn_deri_dev_dap, n_agrid-1, []);

        <span class="comment">% C1. Generate Resources and other matrixes and vectors</span>
        <span class="comment">% C. Generate Vectorized FOC Evaluator</span>
        <span class="comment">% x = fl_aprime_frac</span>
        fc_ffi_vec_foc_u_v_ap = @(x) ffi_vec_foc_u_v_ap(<span class="keyword">...</span>
            x, agrid', <span class="keyword">...</span>
            ar_resources_amz, ar_z_ctr_amz, ar_hh_size_amz, <span class="keyword">...</span>
            mt_deri_dev_dap, <span class="keyword">...</span>
            f_du_da, f_FOC);

        <span class="comment">% D. Solve via Bisection</span>
        mp_bisec_ctrlinfo = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>, <span class="string">'ValueType'</span>,<span class="string">'any'</span>);
        mp_bisec_ctrlinfo(<span class="string">'it_bisect_max_iter'</span>) = 30;
        mp_bisec_ctrlinfo(<span class="string">'fl_x_left_start'</span>) = 10e-6;
        mp_bisec_ctrlinfo(<span class="string">'fl_x_right_start'</span>) = 1-10e-6;

        [ar_opti_saveborr_frac_amz] = <span class="keyword">...</span>
            ff_optim_bisec_savezrone(fc_ffi_vec_foc_u_v_ap,<span class="keyword">...</span>
            false, false, mp_bisec_ctrlinfo);

        <span class="comment">% E. Evaluate at Bounds</span>
        ar_nan_idx = isnan(ar_opti_saveborr_frac_amz);
        <span class="keyword">if</span>(sum(ar_nan_idx)&gt;0)
            ar_min_max = [0, 1-1E-5];
            mt_val_min_max = zeros(sum(ar_nan_idx), length(ar_min_max));
            <span class="keyword">for</span> it_minmax = [1,2]
                [~, mt_val_min_max(:,it_minmax), ~] = ffi_vec_u_v_ap(<span class="keyword">...</span>
                    ar_min_max(it_minmax), agrid', <span class="keyword">...</span>
                    ar_resources_amz(ar_nan_idx), ar_z_ctr_amz(ar_nan_idx), ar_hh_size_amz(ar_nan_idx), <span class="keyword">...</span>
                    mt_ev_ap_z, mt_deri_dev_dap, <span class="keyword">...</span>
                    f_util, f_U);
            <span class="keyword">end</span>
            [~, it_max] =  max(mt_val_min_max, [], 2);
            ar_opti_saveborr_frac_amz(ar_nan_idx) = ar_min_max(it_max);
        <span class="keyword">end</span>

        <span class="comment">% F. Evaluate</span>
        [ar_aprime_amz, ar_val_opti_amz, ar_c_opti_amz] = ffi_vec_u_v_ap(<span class="keyword">...</span>
            ar_opti_saveborr_frac_amz, agrid', <span class="keyword">...</span>
            ar_resources_amz, ar_z_ctr_amz, ar_hh_size_amz, <span class="keyword">...</span>
            mt_ev_ap_z, mt_deri_dev_dap, <span class="keyword">...</span>
            f_util, f_U);

        <span class="comment">% G. Record Results</span>
        mn_val_cur = reshape(ar_val_opti_amz, size(mn_ev_ap_z));
        mn_aprime_cur = reshape(ar_aprime_amz, size(mn_ev_ap_z));
        mn_c_opti_amz = reshape(ar_c_opti_amz, size(mn_ev_ap_z));

        <span class="comment">% H. To main store:</span>
        V_VFI(j,:,:,:,:,:) = mn_val_cur;
        ap_VFI(j,:,:,:,:,:) = mn_aprime_cur;
        cons_VFI(j,:,:,:,:,:) = mn_c_opti_amz;

    <span class="keyword">else</span>

        <span class="keyword">for</span> a=1:n_agrid <span class="comment">% Assets</span>
            <span class="keyword">for</span> eta=1:n_etagrid <span class="comment">% Productivity</span>
                <span class="keyword">for</span> educ=1:n_educgrid <span class="comment">% Educational level</span>
                    <span class="keyword">for</span> married=1:n_marriedgrid <span class="comment">% Marital status</span>
                        <span class="keyword">for</span> kids=1:n_kidsgrid <span class="comment">% Number of kids</span>
                            <span class="keyword">if</span> j==n_jgrid

                                ap_VFI(j,a,eta,educ,married,kids)=0;
                                cons_VFI(j,a,eta,educ,married,kids) = consumption(j,a,eta,educ,married,kids,ap_VFI(j,a,eta,educ,married,kids));

                                <span class="keyword">if</span> cons_VFI(j,a,eta,educ,married,kids)&lt;=0
                                    disp([j,a,eta,educ,married,kids,cons_VFI(j,a,eta,educ,married,kids)])
                                    error(<span class="string">'Non-positive consumption'</span>)
                                <span class="keyword">end</span>

                                V_VFI(j,a,eta,educ,married,kids)=utility(cons_VFI(j,a,eta,educ,married,kids),married,kids);

                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">if</span> (bl_print_vfi)
        disp(strcat([<span class="string">'SNW_VFI_MAIN: Finished Age Group:'</span> num2str(j) <span class="string">' of '</span> num2str(n_jgrid)]));
    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><pre class="codeoutput">SNW_VFI_MAIN: Finished Age Group:18 of 18
SNW_VFI_MAIN: Finished Age Group:17 of 18
SNW_VFI_MAIN: Finished Age Group:16 of 18
SNW_VFI_MAIN: Finished Age Group:15 of 18
SNW_VFI_MAIN: Finished Age Group:14 of 18
SNW_VFI_MAIN: Finished Age Group:13 of 18
SNW_VFI_MAIN: Finished Age Group:12 of 18
SNW_VFI_MAIN: Finished Age Group:11 of 18
SNW_VFI_MAIN: Finished Age Group:10 of 18
SNW_VFI_MAIN: Finished Age Group:9 of 18
SNW_VFI_MAIN: Finished Age Group:8 of 18
SNW_VFI_MAIN: Finished Age Group:7 of 18
SNW_VFI_MAIN: Finished Age Group:6 of 18
SNW_VFI_MAIN: Finished Age Group:5 of 18
SNW_VFI_MAIN: Finished Age Group:4 of 18
SNW_VFI_MAIN: Finished Age Group:3 of 18
SNW_VFI_MAIN: Finished Age Group:2 of 18
SNW_VFI_MAIN: Finished Age Group:1 of 18
</pre><h2 id="10">Timing and Profiling End</h2><pre class="codeinput"><span class="keyword">if</span> (bl_timer)
    toc;
    <span class="keyword">if</span> (length(varargin)==3)
        st_complete_vfi = strjoin(<span class="keyword">...</span>
            [<span class="string">"Completed SNW_VFI_MAIN 1 PERIOD UNEMP SHK"</span>, <span class="keyword">...</span>
             [<span class="string">'SNW_MP_PARAM='</span> char(mp_params(<span class="string">'mp_params_name'</span>))], <span class="keyword">...</span>
             [<span class="string">'SNW_MP_CONTROL='</span> char(mp_controls(<span class="string">'mp_params_name'</span>))] <span class="keyword">...</span>
            ], <span class="string">";"</span>);
    <span class="keyword">else</span>
        st_complete_vfi = strjoin(<span class="keyword">...</span>
            [<span class="string">"Completed SNW_VFI_MAIN"</span>, <span class="keyword">...</span>
             [<span class="string">'SNW_MP_PARAM='</span> char(mp_params(<span class="string">'mp_params_name'</span>))], <span class="keyword">...</span>
             [<span class="string">'SNW_MP_CONTROL='</span> char(mp_controls(<span class="string">'mp_params_name'</span>))] <span class="keyword">...</span>
            ], <span class="string">";"</span>);
    <span class="keyword">end</span>
    disp(st_complete_vfi);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Elapsed time is 1.045049 seconds.
Completed SNW_VFI_MAIN;SNW_MP_PARAM=default_small;SNW_MP_CONTROL=default_test
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="comment">% Utility Maximization First Order Conditions</span>
<span class="keyword">function</span> [ar_dU_dap, ar_aprime] = <span class="keyword">...</span>
    ffi_vec_foc_u_v_ap(ar_aprime_frac_amz, ar_a, <span class="keyword">...</span>
                       ar_resources_amz, ar_z_ctr_amz, ar_hh_size_amz, <span class="keyword">...</span>
                       mt_deri_dev_dap,<span class="keyword">...</span>
                       f_du_da, f_FOC)
<span class="comment">% A. Percentage Asset Choice to Level Asset Choices</span>
ar_aprime = ar_aprime_frac_amz.*(ar_resources_amz);

<span class="comment">% B. Identify the Closest ar_a point to fl_aprime, this is spline knot point</span>
ar_ap_near_lower_idx = sum(ar_a &lt;= ar_aprime, 2);
ar_ap_near_lower_idx(ar_ap_near_lower_idx == length(ar_a)) = length(ar_a) - 1;

<span class="comment">% C. Current consumption</span>
ar_c = ar_resources_amz - ar_aprime;

<span class="comment">% D. Do not need to check fl_c &gt; 0, because asset bound by 0 to 1 open set</span>
ar_du_dap = f_du_da(ar_c, ar_hh_size_amz);

<span class="comment">% E. the marginal effects of additional asset is determined by the slope</span>
<span class="comment">% mt_z_ctr_amz = repmat(ar_z_ctr_amz, [1, size(ar_aprime_frac_amz,2)]);</span>
ar_lin_idx = sub2ind(size(mt_deri_dev_dap), ar_ap_near_lower_idx, ar_z_ctr_amz);
ar_deri_dev_dap = mt_deri_dev_dap(ar_lin_idx);
<span class="comment">% ar_deri_dev_dap = reshape(ar_deri_dev_dap, size(mt_z_ctr_amz));</span>

<span class="comment">% F. overall first order condition, this is the root search objective</span>
ar_dU_dap = f_FOC(ar_du_dap, ar_deri_dev_dap);

<span class="keyword">end</span>

<span class="comment">% Utility given choices</span>
<span class="keyword">function</span> [ar_aprime, ar_val, ar_c] = ffi_vec_u_v_ap(<span class="keyword">...</span>
    ar_aprime_frac, ar_a, <span class="keyword">...</span>
    ar_resources_amz, ar_z_ctr_amz, ar_hh_size_amz, <span class="keyword">...</span>
    mt_ev_ap_z, mt_deri_dev_dap, <span class="keyword">...</span>
    f_util, f_U)
<span class="comment">% A. Percentage Asset Choice to Level Asset Choices</span>
ar_aprime = ar_aprime_frac.*(ar_resources_amz);

<span class="comment">% B. Identify the Closest ar_a point to fl_aprime, this is spline knot point</span>
ar_it_ap_near_lower_idx = sum(ar_a &lt;= ar_aprime, 2);
ar_it_ap_near_lower_idx(ar_it_ap_near_lower_idx == length(ar_a)) = length(ar_a) - 1;

<span class="comment">% C. Current consumption</span>
ar_c = ar_resources_amz - ar_aprime;

<span class="comment">% D. Evaluate Value</span>
ar_u_of_ap = f_util(ar_c, ar_hh_size_amz);

<span class="comment">% the marginal effects of additional asset is determined by the slope</span>
ar_deri_lin_idx = sub2ind(size(mt_deri_dev_dap), ar_it_ap_near_lower_idx, ar_z_ctr_amz);
ar_ev_lin_idx = sub2ind(size(mt_ev_ap_z), ar_it_ap_near_lower_idx, ar_z_ctr_amz);
ar_deri_dev_dap = mt_deri_dev_dap(ar_deri_lin_idx);
ar_ev_ap_lower_idx = mt_ev_ap_z(ar_ev_lin_idx);

<span class="comment">% Ev(a_lower_idx,z) + slope*(fl_aprime - fl_a_lower)</span>
ar_ev_aprime_z = ar_ev_ap_lower_idx + (ar_aprime - ar_a(ar_it_ap_near_lower_idx)').*ar_deri_dev_dap;

<span class="comment">% overall utility at choice</span>
ar_val = f_U(ar_u_of_ap, ar_ev_aprime_z);
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% SNW_VFI_MAIN Solves Policy/Value Function SNW (Bisection Vectorized)
%    Given parameters, iterate over life cycle, given age, marital status,
%    education level and child count, as well as persistent productivity
%    shock process, solve for optimal dynamic savings choices given
%    expectation of kid count transition and productivity shock transition.
%
%    Pref, Technology, and prices SCALARS:
%
%    * BETA discount
%    * THETA total factor productivity normalizer
%    * R interest rate
%
%    Vectorized State Space ARRAYS:
%
%    * AGRID asset grid
%    * ETA_GRID productivity shock grid
%
%    Transition Matrixes ARRAYS:
%
%    * PI_ETA shock productivity transition
%    * PI_KIDS shock kids count transition
%    * PSI shock survival probability
%
%    Permanent Education Type Heterogeneity ARRAYS:
%
%    * EPSILON perfect-foresight education type transition
%    * SS Social Security
%
%    [V_VFI,AP_VFI,CONS_VFI,EXITFLAG_VFI] = SNW_VFI_MAIN(MP_PARAMS) invoke
%    model with externally set parameter map MP_PARAMS.
%
%    [V_VFI,AP_VFI,CONS_VFI,EXITFLAG_VFI] = SNW_VFI_MAIN(MP_PARAMS,
%    MP_CONTROLS) invoke model with externally set parameter map MP_PARAMS
%    as well as control mpa MP_CONTROLS.
%
%    [V_VFI,AP_VFI,CONS_VFI,EXITFLAG_VFI] = SNW_VFI_MAIN(MP_PARAMS,
%    MP_CONTROLS, V_VFI_FIX) provides existing value function. Suppose
%    there is sudden shock, but future value is preserved after one period.
%    So now we have new value that is specific to this period, that is the
%    output V_VFI, the input V_VFI_FIX is the value for all future periods.
%    When this program is called with V_VFI_FIX, the resource equation will
%    use the unemployment shock information.
%
%    See also SNWX_VFI_MAIN, SNW_MP_CONTROL, SNW_MP_PARAM
%

%%
function [V_VFI,ap_VFI,cons_VFI,exitflag_VFI]=snw_vfi_main_bisec_vec(varargin)

%% Default and Parse
if (~isempty(varargin))

    if (length(varargin)==1)
        [mp_params] = varargin{:};
        mp_controls = snw_mp_control('default_base');
    elseif (length(varargin)==2)
        [mp_params, mp_controls] = varargin{:};
    elseif (length(varargin)==3)
        [mp_params, mp_controls, V_VFI_POSTSHOCK] = varargin{:};
    end

else

    mp_params = snw_mp_param('default_small');
    mp_controls = snw_mp_control('default_test');

end

%% Reset All globals
% globals = who('global');
% clear(globals{:});
% Parameters used in this code directly
global beta theta r agrid epsilon SS pi_eta pi_kids psi n_jgrid n_agrid n_etagrid n_educgrid n_marriedgrid n_kidsgrid
% Used in functions that are called by this code
global gamma g_n g_cons a2 cons_allocation_rule jret
% July 1st new parameters
global eta_H_grid eta_S_grid Bequests bequests_option throw_in_ocean

%% Parse Model Parameters
params_group = values(mp_params, {...
    'gamma', 'beta', 'theta', 'cons_allocation_rule', ...
    'r', 'g_n', 'g_cons', 'a2', 'jret'});
[gamma, beta, theta, cons_allocation_rule, ...
    r, g_n, g_cons, a2, jret] = params_group{:};

params_group = values(mp_params, {'Bequests', 'bequests_option', 'throw_in_ocean'});
[Bequests, bequests_option, throw_in_ocean] = params_group{:};

params_group = values(mp_params, {'agrid', 'eta_H_grid', 'eta_S_grid'});
[agrid, eta_H_grid, eta_S_grid] = params_group{:};

params_group = values(mp_params, ...
    {'pi_eta', 'pi_kids', 'psi'});
[pi_eta, pi_kids, psi] = params_group{:};

params_group = values(mp_params, {'epsilon', 'SS'});
[epsilon, SS] = params_group{:};

params_group = values(mp_params, ...
    {'n_jgrid', 'n_agrid', 'n_etagrid', 'n_educgrid', 'n_marriedgrid', 'n_kidsgrid'});
[n_jgrid, n_agrid, n_etagrid, n_educgrid, n_marriedgrid, n_kidsgrid] = params_group{:};

% unemployment parameters under covid
if (length(varargin)==3)    
    params_group = values(mp_params, {'xi','b'});
    [xi, b] = params_group{:};    
end

%% Parse Model Controls
% Profiling Controls
params_group = values(mp_controls, {'bl_timer'});
[bl_timer] = params_group{:};

% Display Controls
params_group = values(mp_controls, {'bl_print_vfi', 'bl_print_vfi_verbose'});
[bl_print_vfi, bl_print_vfi_verbose] = params_group{:};

% Store Controls
params_group = values(mp_controls, {'bl_vfi_store_all'});
[bl_vfi_store_all] = params_group{:};

%% Define Functions

% Current Function and their Derivatives
hh_power=1/cons_allocation_rule;
if(gamma == 1)     
    f_util = @(c,hh_size) log(c./(hh_size.^hh_power));
    f_du_da = @(c,hh_size) (-1)./(c);
else
    f_util = @(c,hh_size) ((c./(hh_size.^hh_power)).^(1-gamma)-1)./(1-gamma);
    f_du_da = @(c,hh_size) (-(hh_size.^(hh_power.*(gamma-1))))./(c.^gamma);
end

% Utility 
f_U = @(u, Ev) (u + beta.*Ev);
f_FOC = @(duda, devda) (duda + beta.*devda);

%% Timing and Profiling Start
if (bl_timer)
    tic
end

%% Solve optimization problem

V_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
ap_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
cons_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
% if (bl_vfi_store_all)
%     y_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
%     tax_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
%     SS_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
% end

exitflag_VFI=NaN(n_jgrid,n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);

% Solve for value function and policy functions by means of backwards induction
for j=n_jgrid:(-1):1 % Age
    
    % A1. Generate the Resources Matrix
    mn_resources = zeros(n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);    
    mn_z_ctr = zeros(n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
    mn_hh_size = zeros(n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
    for a=1:n_agrid % Assets
        it_z_ctr = 0;
        % order here is reverse of order of loops at L181, so that it_z_ctr
        % match up with column order after reshape(mn_ev_ap_z, n_agrid, [])
        for kids=1:n_kidsgrid % Number of kids
            for married=1:n_marriedgrid % Marital status
                for educ=1:n_educgrid % Educational level
                    for eta=1:n_etagrid % Productivity
                        
                        % Resources
                        if (length(varargin)==3)
                            % one period unemployed shock
                            [inc,earn]=individual_income(j,a,eta,educ,xi,b);
                        else
                            [inc,earn]=individual_income(j,a,eta,educ);
                        end
                        spouse_inc=spousal_income(j,educ,kids,earn,SS(j,educ));
                        resources = (1+r)*(agrid(a)+Bequests*(bequests_option-1)) ...
                                    + epsilon(j,educ)*theta*exp(eta_H_grid(eta)) ...
                                    + SS(j,educ) ...
                                    + (married-1)*spouse_inc*exp(eta_S_grid(eta)) ...
                                    - max(0,Tax(inc,(married-1)*spouse_inc*exp(eta_S_grid(eta))));
                        mn_resources(a, eta, educ, married, kids) = resources;
                        
                        % Non-asset position Counter
                        it_z_ctr = it_z_ctr + 1;
                        mn_z_ctr(a, eta, educ, married, kids) = it_z_ctr;
                        
                        % Household Size: 1 kid married, hh_size = 2 + 2 -
                        % 1 = 3. 0 kid and unmarried hh_size = 1 + 1 - 1 =
                        % 1
                        hh_size = married + kids - 1; % m=1 if single; m=2 if married; k=1 if 0 children
                        mn_hh_size(a, eta, educ, married, kids) = hh_size;
                        
                    end
                end
            end
        end
    end
    
    % array states/shocks all
    ar_resources_amz = mn_resources(:);
    ar_z_ctr_amz = mn_z_ctr(:);
    ar_hh_size_amz = mn_hh_size(:);
    
    % A2. Solve For EV(ap,z) = EV(ap,zp|z)f(zp|z) for all possible ap points
    % ev = 0 in final decision period.
    mn_ev_ap_z = zeros(n_agrid,n_etagrid,n_educgrid,n_marriedgrid,n_kidsgrid);
    
    if (j~=n_jgrid)
        
        if (length(varargin)==3)
            V_VFI_FUTURE = V_VFI_POSTSHOCK;
        else
            V_VFI_FUTURE = V_VFI;
        end
        
        for eta=1:n_etagrid % Productivity
            for educ=1:n_educgrid % Educational level
                for married=1:n_marriedgrid % Marital status
                    for kids=1:n_kidsgrid % Number of kids
                        for a=1:n_agrid
                            % Add to each cell of mt_ev_ap_z, integrating over f(zp|z)
                            for etap=1:n_etagrid
                                for kidsp=1:n_kidsgrid                                    
                                    mn_ev_ap_z(a,eta,educ,married,kids) = ...
                                        mn_ev_ap_z(a,eta,educ,married,kids) ...
                                        + psi(j)*pi_eta(eta,etap)*pi_kids(kids,kidsp,j,educ,married)...
                                          *V_VFI_FUTURE(j+1,a,etap,educ,married,kidsp);
                                end
                            end

                        end
                    end
                end
            end
        end

        % B1. z specific EV Slope: EV(ap,z)/d(ap)
        mn_deri_dev_dap = diff(mn_ev_ap_z, 1)./diff(agrid);    
        % B2. ND dimensional Array to 2D dimensional Array:
        mt_ev_ap_z = reshape(mn_ev_ap_z, n_agrid, []);
        mt_deri_dev_dap = reshape(mn_deri_dev_dap, n_agrid-1, []);

        % C1. Generate Resources and other matrixes and vectors
        % C. Generate Vectorized FOC Evaluator
        % x = fl_aprime_frac
        fc_ffi_vec_foc_u_v_ap = @(x) ffi_vec_foc_u_v_ap(...
            x, agrid', ...
            ar_resources_amz, ar_z_ctr_amz, ar_hh_size_amz, ...
            mt_deri_dev_dap, ...
            f_du_da, f_FOC);
        
        % D. Solve via Bisection 
        mp_bisec_ctrlinfo = containers.Map('KeyType','char', 'ValueType','any');
        mp_bisec_ctrlinfo('it_bisect_max_iter') = 30;
        mp_bisec_ctrlinfo('fl_x_left_start') = 10e-6;
        mp_bisec_ctrlinfo('fl_x_right_start') = 1-10e-6;

        [ar_opti_saveborr_frac_amz] = ...
            ff_optim_bisec_savezrone(fc_ffi_vec_foc_u_v_ap,...
            false, false, mp_bisec_ctrlinfo);

        % E. Evaluate at Bounds
        ar_nan_idx = isnan(ar_opti_saveborr_frac_amz);    
        if(sum(ar_nan_idx)>0)
            ar_min_max = [0, 1-1E-5];
            mt_val_min_max = zeros(sum(ar_nan_idx), length(ar_min_max));
            for it_minmax = [1,2]
                [~, mt_val_min_max(:,it_minmax), ~] = ffi_vec_u_v_ap(...
                    ar_min_max(it_minmax), agrid', ...
                    ar_resources_amz(ar_nan_idx), ar_z_ctr_amz(ar_nan_idx), ar_hh_size_amz(ar_nan_idx), ...
                    mt_ev_ap_z, mt_deri_dev_dap, ...
                    f_util, f_U);
            end
            [~, it_max] =  max(mt_val_min_max, [], 2);
            ar_opti_saveborr_frac_amz(ar_nan_idx) = ar_min_max(it_max);
        end

        % F. Evaluate 
        [ar_aprime_amz, ar_val_opti_amz, ar_c_opti_amz] = ffi_vec_u_v_ap(...
            ar_opti_saveborr_frac_amz, agrid', ...
            ar_resources_amz, ar_z_ctr_amz, ar_hh_size_amz, ...
            mt_ev_ap_z, mt_deri_dev_dap, ...
            f_util, f_U);

        % G. Record Results    
        mn_val_cur = reshape(ar_val_opti_amz, size(mn_ev_ap_z));
        mn_aprime_cur = reshape(ar_aprime_amz, size(mn_ev_ap_z));
        mn_c_opti_amz = reshape(ar_c_opti_amz, size(mn_ev_ap_z));
        
        % H. To main store:
        V_VFI(j,:,:,:,:,:) = mn_val_cur;
        ap_VFI(j,:,:,:,:,:) = mn_aprime_cur;
        cons_VFI(j,:,:,:,:,:) = mn_c_opti_amz;
        
    else

        for a=1:n_agrid % Assets
            for eta=1:n_etagrid % Productivity
                for educ=1:n_educgrid % Educational level
                    for married=1:n_marriedgrid % Marital status
                        for kids=1:n_kidsgrid % Number of kids
                            if j==n_jgrid
                                
                                ap_VFI(j,a,eta,educ,married,kids)=0;
                                cons_VFI(j,a,eta,educ,married,kids) = consumption(j,a,eta,educ,married,kids,ap_VFI(j,a,eta,educ,married,kids));

                                if cons_VFI(j,a,eta,educ,married,kids)<=0
                                    disp([j,a,eta,educ,married,kids,cons_VFI(j,a,eta,educ,married,kids)])
                                    error('Non-positive consumption')
                                end
                                
                                V_VFI(j,a,eta,educ,married,kids)=utility(cons_VFI(j,a,eta,educ,married,kids),married,kids);
                                
                            end
                        end
                    end
                end
            end
        end
        
    end
    
    if (bl_print_vfi)
        disp(strcat(['SNW_VFI_MAIN: Finished Age Group:' num2str(j) ' of ' num2str(n_jgrid)]));
    end

end

%% Timing and Profiling End
if (bl_timer)
    toc;
    if (length(varargin)==3)
        st_complete_vfi = strjoin(...
            ["Completed SNW_VFI_MAIN 1 PERIOD UNEMP SHK", ...
             ['SNW_MP_PARAM=' char(mp_params('mp_params_name'))], ...
             ['SNW_MP_CONTROL=' char(mp_controls('mp_params_name'))] ...
            ], ";");
    else
        st_complete_vfi = strjoin(...
            ["Completed SNW_VFI_MAIN", ...
             ['SNW_MP_PARAM=' char(mp_params('mp_params_name'))], ...
             ['SNW_MP_CONTROL=' char(mp_controls('mp_params_name'))] ...
            ], ";");
    end
    disp(st_complete_vfi);
end

end

% Utility Maximization First Order Conditions
function [ar_dU_dap, ar_aprime] = ...
    ffi_vec_foc_u_v_ap(ar_aprime_frac_amz, ar_a, ...
                       ar_resources_amz, ar_z_ctr_amz, ar_hh_size_amz, ...
                       mt_deri_dev_dap,...
                       f_du_da, f_FOC)
% A. Percentage Asset Choice to Level Asset Choices
ar_aprime = ar_aprime_frac_amz.*(ar_resources_amz);

% B. Identify the Closest ar_a point to fl_aprime, this is spline knot point
ar_ap_near_lower_idx = sum(ar_a <= ar_aprime, 2);
ar_ap_near_lower_idx(ar_ap_near_lower_idx == length(ar_a)) = length(ar_a) - 1;

% C. Current consumption
ar_c = ar_resources_amz - ar_aprime;

% D. Do not need to check fl_c > 0, because asset bound by 0 to 1 open set
ar_du_dap = f_du_da(ar_c, ar_hh_size_amz);

% E. the marginal effects of additional asset is determined by the slope
% mt_z_ctr_amz = repmat(ar_z_ctr_amz, [1, size(ar_aprime_frac_amz,2)]);
ar_lin_idx = sub2ind(size(mt_deri_dev_dap), ar_ap_near_lower_idx, ar_z_ctr_amz);
ar_deri_dev_dap = mt_deri_dev_dap(ar_lin_idx);
% ar_deri_dev_dap = reshape(ar_deri_dev_dap, size(mt_z_ctr_amz));

% F. overall first order condition, this is the root search objective
ar_dU_dap = f_FOC(ar_du_dap, ar_deri_dev_dap);

end

% Utility given choices
function [ar_aprime, ar_val, ar_c] = ffi_vec_u_v_ap(...
    ar_aprime_frac, ar_a, ...
    ar_resources_amz, ar_z_ctr_amz, ar_hh_size_amz, ...
    mt_ev_ap_z, mt_deri_dev_dap, ...
    f_util, f_U)
% A. Percentage Asset Choice to Level Asset Choices
ar_aprime = ar_aprime_frac.*(ar_resources_amz);

% B. Identify the Closest ar_a point to fl_aprime, this is spline knot point
ar_it_ap_near_lower_idx = sum(ar_a <= ar_aprime, 2);
ar_it_ap_near_lower_idx(ar_it_ap_near_lower_idx == length(ar_a)) = length(ar_a) - 1;

% C. Current consumption
ar_c = ar_resources_amz - ar_aprime;

% D. Evaluate Value
ar_u_of_ap = f_util(ar_c, ar_hh_size_amz);

% the marginal effects of additional asset is determined by the slope
ar_deri_lin_idx = sub2ind(size(mt_deri_dev_dap), ar_it_ap_near_lower_idx, ar_z_ctr_amz);
ar_ev_lin_idx = sub2ind(size(mt_ev_ap_z), ar_it_ap_near_lower_idx, ar_z_ctr_amz);
ar_deri_dev_dap = mt_deri_dev_dap(ar_deri_lin_idx);
ar_ev_ap_lower_idx = mt_ev_ap_z(ar_ev_lin_idx);

% Ev(a_lower_idx,z) + slope*(fl_aprime - fl_a_lower)
ar_ev_aprime_z = ar_ev_ap_lower_idx + (ar_aprime - ar_a(ar_it_ap_near_lower_idx)').*ar_deri_dev_dap;

% overall utility at choice
ar_val = f_U(ar_u_of_ap, ar_ev_aprime_z);
end

##### SOURCE END #####
--></body></html>